---
title: c++中模板类的成员函数的声明与定义应该放在头文件里
categories: 后台开发
tags: 后台开发

---
  今天尝试自己实现模板类的时候，还想像往常一样把类分为.h文件和.cpp文件，把成员函数的声明放在.h文件中，把具体实现放在.cpp文件中，结果在测试时发现在编译过程中报错。调试了很久，重视提示“无法解析的外部符号”，如图所示：
![](/public/image/2018-9-26-1.png)
  在网上查找资料和翻阅书籍后,<<C++primer>>里面有提到：C++支持两种模板编译模式包含模式Inclusion  Model  和分离模式Separation  Model 

#1包含模式（Inclusion Model)#
  在包含编译模式下我们在每个模板被实例化的文件中包含函数模板的定义并且往往把定义放在头文件中像对内联函数所做的那样

#2分离编译模式#
  在分离编译模式下函数模板的声明被放在头文件中 ,  在模板定义中有一个关键字export,  关键字export  告诉编译器在生成被其他文件使用的函数模板实例时可能需要这个模板定义编译器必须保证在生成这些实例时该模板定义是可见的 , 关键字export 不需要出现在头文件的模板声明中, 分离模式使我们能够很好地将函数模板的接口同其实现分开进而组织好程序以便把函数模板的接口放到头文件中而把实现放在文本文件中, 但是并不是所有的编译器都支持分离模式, 即使支持也未必总能支持得很好, 支持分离模式需要更复杂的程序设计环境所以它们不能在所有C++编译器实现中提供. 现在的VC++编译器都不知道模板分离编译模式，所以还是要把定义与实现都放在一个文件中。<br><br>
  再回头看上面的例子，可以知道构造函数也是一个模板，在main.cpp中创建一个vector要创建一个构造函数模板的实例 。实例化要素体现在main.cpp文件中，如一些函数的实参(a,b,c)。如果按照传统方式，编译器在vector.h文件中看到了模板的声明，但没有模板的定义，这样编译器就不能创建vector(a,b,c)。但这时并不出错，因为编译器认为模板定义在其它文件中，就把问题留给链接程序处理。 现在，编译vector.cpp时会发生什么问题呢？编译器可以解析模板定义并检查语法，但不能生成成员函数的代码。它无法生成代码，因为要生成代码，需要知道模板参数，即需要一个类型，而不是模板本身。这样，链接程序在main.cpp 或 vector.cpp中都找不到vector(a,b,c)的定义，于是报出无定义成员的错误。
