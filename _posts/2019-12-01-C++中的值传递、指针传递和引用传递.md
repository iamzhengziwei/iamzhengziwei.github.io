---
title: C++中的值传递、指针传递和引用传递
categories: 后台开发
tags: 后台开发

---
#C++中的值传递、指针传递和引用传递#  
话不多说，先上代码，在代码中看区别
```cpp
#include<iostream>
using namespace std;
//值传递
void zhiChuandi(int n) {
	cout << "值传递--函数操作地址" << &n << endl;         //显示的是拷贝的地址而不是源地址 
	n++;
}

//引用传递
void YinyongChuandi(int & n) {
	cout << "引用传递--函数操作地址" << &n << endl;
	n++;
}
//指针传递
void ZhizhenChuandi(int *n) {
	cout << "指针传递--函数操作地址 " << n << endl;
	*n += 1;
}
int     main() {
	int n = 10;
	cout << "实参n的地址" << &n << endl;
	zhiChuandi(n);
	cout << "after zhiChuandi() n=" << n << endl;
	YinyongChuandi(n);
	cout << "after YinyongChuandi() n=" << n << endl;
	ZhizhenChuandi(&n);
	cout << "after ZhizhenChuandi() n=" << n << endl;
	system("pause");
	return true;
}
```

运行结果如图
![](/public/image/2019-12-01-1.png)
值传递和引用传递虽然在调用时都写的是“n”，即zhiChuandi(n)和YinyongChuandi(2）但其背后实际操作截然不同，值传递很好理解，相当于做了一个copy，在不影响原变量值的情况下，仅对copy好的新变量进行操作。但引用传递，或者理解成“址传递”，虽然也写成YinyongChuandi(n)，但他实际上根据YinyongChuandi(int &n)这个函数定义，把拿到的参数n的内存地址给搞到了，然后后续在函数体中虽然也一直写n怎么怎么样，但这个操作其实已经是对原参数（而非新的copy）的操作了。指针传递是另外一种形式的“址传递”，他和“引用传递”的区别在于：如果认为引用传递稍微“智能”一些，即只需在函数定义的形参上加一个&表示要取的是地址就行，指针传递则更加“低级粗暴”，直接在函数定义时指明形参要的就是地址值，要求把地址传递进来。所以在写ZhizhenChuandi(&n)时，就不和YinyongChuandi(n)这般这么智能方便，而是必须手工写上取地址符&，从而把地址传进来。另外，在函数体内的使用中，明显发现引用传递要简单一些，变量该怎么写还是怎么写，相当于忽略该独立出来的函数，直接操作原数。而指针传递就得不断的加去内容符 *，比如*n=*n+1，这是因为传递进来的n本身是个地址，不得不加 * 去该地址取内容。
